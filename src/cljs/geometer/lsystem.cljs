(ns geometer.lsystem
  (:require [thi.ng.geom.core        :as g]
            [thi.ng.geom.core.vector :refer [vec3]]
            [thi.ng.geom.core.matrix :refer [M44]]
            [thi.ng.geom.aabb        :refer [aabb]]
            [thi.ng.geom.basicmesh   :as bm]
            [thi.ng.geom.types.utils :as tu]
            [thi.ng.math.core        :as m]))

(defn grow-cuboid
  "Add a cuboid branch of `length` to `mesh` from `position` with `rotation`. (Produces somewhat organic-looking segments)."
  [length mesh position rotation]
  (let [[x y z] (last rotation)
        tx      (-> M44
                    (g/translate (last position))
                    (g/rotate-x x)
                    (g/rotate-y y)
                    (g/rotate-z z))
        corners (g/transform (aabb (vec3 -0.25 -0.25 0) (vec3 0.5 0.5 length)) tx)
        last-c  (g/transform (vec3 0 0 length) tx)]
    [(conj (pop position) last-c)
     rotation
     (g/into mesh (g/as-mesh corners))]))

(defn- execute-op
  "Execute a single L-System operation and return the new state of the system. The `angle-fn` is used to determine angle changes and the `grow-fn` to extend a branch."
  [angle-fn grow-fn [pos rot mesh] op]
  (case op
    \F (grow-fn mesh pos rot)
    \C [(conj (pop pos) (vec3 0 0 0)) (conj (pop rot) (vec3 0 0 0)) mesh]
    \+ [pos (conj (pop rot) (g/+ (last rot) (vec3 0 (angle-fn) 0))) mesh]
    \- [pos (conj (pop rot) (g/+ (last rot) (vec3 0 (- (angle-fn)) 0))) mesh]
    \& [pos (conj (pop rot) (g/+ (last rot) (vec3 (angle-fn) 0 0))) mesh]
    \^ [pos (conj (pop rot) (g/+ (last rot) (vec3 (- (angle-fn)) 0 0))) mesh]
    \\ [pos (conj (pop rot) (g/+ (last rot) (vec3 0 0 (angle-fn)))) mesh]
    \/ [pos (conj (pop rot) (g/+ (last rot) (vec3 0 0 (- (angle-fn))))) mesh]
    \| [pos (conj (pop rot) (g/+ (last rot) (vec3 0 (m/radians 180) 0))) mesh]
    \[ [(conj pos (last pos)) (conj rot (last rot)) mesh]
    \] (if (or (= 1 (count pos)) (= 1 (count rot))) ; guard against popping empties
         [pos rot mesh]
         [(pop pos) (pop rot) mesh])
    [pos rot mesh]))                                ; default to no-op

(defn execute-ops
  "Execute a sequence of L-System `ops` starting from `state` parameterized by `angle-fn` and `grow-fn`, returns the resulting state."
  [angle-fn grow-fn state ops]
  (reduce #(execute-op angle-fn grow-fn %1 %2) state ops))

(defn expand-l-system
  "Recursively expand a L-System grammar into a sequence of operations."
  [rules curr-state depth]
  (if (zero? depth)
    curr-state
    (mapcat #(expand-l-system rules (rules % [%]) (dec depth)) curr-state)))

(defn build-lsystem
  "Perform a sequence of L-System operations on a newly created mesh, return the result."
  [angle-fn grow-fn l-system]
  (g/center (last (execute-ops angle-fn grow-fn [[(vec3 0 0 0)] [(vec3 0 0 0)] (bm/basic-mesh)] l-system))))

(defn algae
  "Returns a mesh generated by an L-System that produces something like algae, or a piece of parsley."
  []
  (build-lsystem #(m/radians (+ (m/random -15 15) 35))
                 #(grow-cuboid (m/random 2 4) %1 %2 %3)
                 (expand-l-system {\F "F[&&+F]F[-\\F][-\\^F][&F][&+F]"} "F" 4)))

(defn koch
  "Returns a mesh generated by an L-System that produces 3D version of a Koch curve."
  []
  (build-lsystem (constantly (m/radians 90))
                 (partial grow-cuboid 3)
                 (expand-l-system {\F "FF-F-F&F-F-F+F"} "F" 3)))

(defn toroid
  "Generates a toroid using the L-System support functions."
  []
  (build-lsystem (constantly (m/radians 15))
                 (partial grow-cuboid 4)
                 (take 48 (cycle [\F \+]))))
