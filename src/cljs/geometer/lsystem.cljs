(ns geometer.lsystem
  (:require [thi.ng.geom.core        :as g]
            [thi.ng.geom.core.vector :refer [vec3]]
            [thi.ng.geom.core.matrix :refer [M44]]
            [thi.ng.geom.aabb        :refer [aabb]]
            [thi.ng.geom.basicmesh   :as bm]
            [thi.ng.math.core        :as m]))

(defn expand-l-system
  "Recursively expand a L-System grammar into a sequence of operations."
  [rules curr-state depth]
  (if (zero? depth)
    curr-state
    (mapcat #(expand-l-system rules (rules % [%]) (dec depth)) curr-state)))

(def initial-state
  "Template for starting state to be passed to L-System construction functions."
  [[M44] (bm/basic-mesh)])

(defn grow-cuboid
  "Add a cuboid branch of `length` to `mesh` from `position` with `rotation`."
  [length mat mesh]
  (let [curr-mat (last mat)]
    [(conj (pop mat) (g/translate curr-mat 0 0 length))
     (g/into mesh (-> (aabb (vec3 -0.25 -0.25 0) (vec3 0.5 0.5 length))
                      (g/transform curr-mat)
                      (g/as-mesh)))]))

(defn- execute-op
  "Execute a single L-System operation and return the new state of the system. The `angle-fn` is used to determine angle changes and the `grow-fn` to extend a branch."
  [angle-fn grow-fn [mat mesh] op]
  (case op
    \F (grow-fn mat mesh)
    \C [(conj (pop mat) M44) mesh]
    \+ [(conj (pop mat) (g/rotate-y (last mat) (angle-fn))) mesh]
    \- [(conj (pop mat) (g/rotate-y (last mat) (- (angle-fn)))) mesh]
    \& [(conj (pop mat) (g/rotate-x (last mat) (angle-fn))) mesh]
    \^ [(conj (pop mat) (g/rotate-x (last mat) (- (angle-fn)))) mesh]
    \\ [(conj (pop mat) (g/rotate-z (last mat) (angle-fn))) mesh]
    \/ [(conj (pop mat) (g/rotate-z (last mat) (- (angle-fn)))) mesh]
    \| [(conj (pop mat) (g/rotate-y (last mat) (m/radians 180))) mesh]
    \[ [(conj mat (last mat)) mesh]
    \] (if (= 1 (count mat)) ; guard against popping empties
         [mat mesh]
         [(pop mat) mesh])
    [mat mesh]))             ; default to no-op

(defn execute-ops
  "Execute a sequence of L-System `ops` starting from `state` parameterized by `angle-fn` and `grow-fn`, returns the resulting state."
  [angle-fn grow-fn state ops]
  (reduce #(execute-op angle-fn grow-fn %1 %2) state ops))

(defn build-lsystem
  "Perform a sequence of L-System operations on a newly created mesh, return the result."
  [angle-fn grow-fn l-system]
  (last (execute-ops angle-fn grow-fn initial-state l-system)))

(defn algae
  "Returns a mesh generated by an L-System that produces something like algae, or a piece of parsley."
  []
  (build-lsystem #(m/radians (+ (m/random -15 15) 35))
                 #(grow-cuboid (m/random 2 4) %1 %2)
                 (expand-l-system {\F "F[&&+F]F[-\\F][-\\^F][&F][&+F]"} "F" 4)))

(defn koch
  "Returns a mesh generated by an L-System that produces 3D version of a Koch curve."
  []
  (build-lsystem (constantly (m/radians 90))
                 (partial grow-cuboid 3)
                 (expand-l-system {\F "FF-F-F&F-F-F+F"} "F" 3)))

(defn toroid
  "Generates a toroid using the L-System support functions."
  []
  (build-lsystem (constantly (m/radians 15))
                 (partial grow-cuboid 4)
                 (take 48 (cycle [\F \+]))))
