(ns geometer.lsystem
  (:require [thi.ng.geom.core        :as g]
            [thi.ng.geom.core.vector :refer [vec3]]
            [thi.ng.geom.cuboid      :refer [cuboid]]
            [thi.ng.geom.gmesh       :as gm]
            [thi.ng.geom.types.utils :as tu]
            [thi.ng.math.core        :as m]))

(defn grow-cuboid
  "Add a cuboid branch of `length` to `mesh` from `position` with `rotation`. (Produces somewhat organic-looking segments)."
  [length mesh position rotation]
  (let [[x y z] (last rotation)
        corners (map #(-> % (g/rotate-x x) (g/rotate-y y) (g/rotate-z z) (g/+ (last position)))
                     [(vec3 0 0 0) (vec3 -1 0 0) (vec3 0 -1 0) (vec3 0 1 0)
                      (vec3 -1 0 length) (vec3 0 -1 length) (vec3 0 1 length) (vec3 0 0 length)])]
    [(conj (pop position) (last corners))
     rotation
     (tu/into-mesh mesh gm/add-face (apply cuboid corners))]))

(defn- execute-op
  "Execute a single L-System operation and return the new state of the system. The `angle-fn` is used to determine angle changes and the `grow-fn` to extend a branch."
  [angle-fn grow-fn [pos rot mesh] op]
  (case op
    \F (grow-fn mesh pos rot)
    \C [(conj (pop pos) (vec3 0 0 0)) (conj (pop rot) (vec3 0 0 0)) mesh]
    \+ [pos (conj (pop rot) (g/+ (last rot) (vec3 0 (angle-fn) 0))) mesh]
    \- [pos (conj (pop rot) (g/+ (last rot) (vec3 0 (- (angle-fn)) 0))) mesh]
    \& [pos (conj (pop rot) (g/+ (last rot) (vec3 (angle-fn) 0 0))) mesh]
    \^ [pos (conj (pop rot) (g/+ (last rot) (vec3 (- (angle-fn)) 0 0))) mesh]
    \\ [pos (conj (pop rot) (g/+ (last rot) (vec3 0 0 (angle-fn)))) mesh]
    \/ [pos (conj (pop rot) (g/+ (last rot) (vec3 0 0 (- (angle-fn))))) mesh]
    \| [pos (conj (pop rot) (g/+ (last rot) (vec3 0 (m/radians 180) 0))) mesh]
    \[ [(conj pos (last pos)) (conj rot (last rot)) mesh]
    \] (if (or (= 1 (count pos)) (= 1 (count rot))) ; guard against popping empties
         [pos rot mesh]
         [(pop pos) (pop rot) mesh]) 
    [pos rot mesh]))                                ; default to no-op

(defn execute-ops
  "Execute a sequence of L-System `ops` starting from `state` parameterized by `angle-fn` and `grow-fn`, returns the resulting state."
  [angle-fn grow-fn state ops]
  (reduce #(execute-op angle-fn grow-fn %1 %2) state ops))

(defn expand-l-system
  "Recursively expand a L-System grammar into a sequence of operations."
  [rules curr-state depth]
  (if (zero? depth)
    curr-state 
    (mapcat #(expand-l-system rules (rules % [%]) (dec depth)) curr-state)))

(defn build-lsystem
  "Perform a sequence of L-System operations on a newly created mesh, return the result."
  [angle-fn grow-fn l-system]
  (last (execute-ops angle-fn grow-fn [[(vec3 0 0 0)] [(vec3 0 0 0)] (gm/gmesh)] l-system)))

(defn algae
  "Returns a mesh generated by an L-System that produces something like algae, or a piece of parsley."
  []
  (build-lsystem #(m/radians (+ (m/random -5 5) 35))
                 #(grow-cuboid (m/random 2 4) %1 %2 %3)
                 (expand-l-system {\F "F[&&+F]F[-\\F][-\\^F][&F][&+F]"} "F" 3)))

(defn koch
  "Returns a mesh generated by an L-System that produces 3D version of a Koch curve."
  []
  (build-lsystem #(m/radians 90)
                 (partial grow-cuboid 3)
                 (expand-l-system {\F "FF-F-F&F-F-F+F"} "F" 3)))

(defn toroid
  "Generates a toroid using the L-System support functions."
  []
  (build-lsystem #(m/radians 15)
                 (partial grow-cuboid 4)
                 (take 48 (cycle [\F \+]))))
