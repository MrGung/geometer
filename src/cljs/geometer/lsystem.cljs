(ns geometer.lsystem
  (:require [thi.ng.geom.core        :as g]
            [thi.ng.geom.core.vector :as v :refer [vec2 vec3]]
            [thi.ng.geom.cuboid      :refer [cuboid]]
            [thi.ng.geom.gmesh       :as gm]
            [thi.ng.geom.types.utils :as tu]
            [thi.ng.math.core        :as m]))

(defn grow
  "Add a cuboid branch to `mesh` from `position` with `rotation` for `length`. (Produces somewhat organic-looking segments)."
  [mesh position rotation length]
  (let [[x y z] (last rotation)
        corners (map #(-> % (g/rotate-x x) (g/rotate-y y) (g/rotate-z z) (g/+ (last position)))
                     [(vec3 0 0 0) (vec3 -1 0 0) (vec3 0 -1 0) (vec3 0 1 0)
                      (vec3 -1 0 length) (vec3 0 -1 length) (vec3 0 1 length) (vec3 0 0 length)])]
    [(conj (pop position) (last corners))
     rotation
     (tu/into-mesh mesh gm/add-face (apply cuboid corners))]))

(defn- execute-op
  "Execute a single L-System operation and return the new state of the system."
  [[pos rot mesh] op angle len]
  (case op
    \F (grow mesh pos rot (len))
    \C [(conj (pop pos) (vec3 0 0 0)) (conj (pop rot) (vec3 0 0 0)) mesh]
    \+ [pos (conj (pop rot) (g/+ (last rot) (vec3 0 (angle) 0))) mesh]
    \- [pos (conj (pop rot) (g/+ (last rot) (vec3 0 (- (angle)) 0))) mesh]
    \& [pos (conj (pop rot) (g/+ (last rot) (vec3 (angle) 0 0))) mesh]
    \^ [pos (conj (pop rot) (g/+ (last rot) (vec3 (- (angle)) 0 0))) mesh]
    \\ [pos (conj (pop rot) (g/+ (last rot) (vec3 0 0 (angle)))) mesh]
    \/ [pos (conj (pop rot) (g/+ (last rot) (vec3 0 0 (- (angle))))) mesh]
    \| [pos (conj (pop rot) (g/+ (last rot) (vec3 0 (m/radians 180) 0))) mesh]
    \[ [(conj pos (last pos)) (conj rot (last rot)) mesh]
    \] (if (or (= 1 (count pos)) (= 1 (count rot))) ;; guard against popping empties
         [pos rot mesh]
         [(pop pos) (pop rot) mesh]) 
    [pos rot mesh])) ;; default to no-op

(defn execute-ops
  "Execute a sequence of L-System operations and return the new state of the system."
  [state ops angle len]
  (reduce #(execute-op %1 %2 angle len) state ops))

(defn expand-l-system
  "Recursively expand a L-System grammar into a sequence of operations."
  [rules curr-state depth]
  (if (zero? depth)
    curr-state 
    (mapcat #(expand-l-system rules (rules % [%]) (dec depth)) curr-state)))

(defn build-lsystem
  "Perform a sequence of L-System operations on a newly created mesh, return the result."
  [l-system angle len]
  (last (execute-ops [[(vec3 0 0 0)] [(vec3 0 0 0)] (gm/gmesh)] l-system angle len)))

(defn algae
  "Returns a mesh generated by an L-System that produces something like algae, or a piece of parsley."
  []
  (build-lsystem (expand-l-system {\F "F[&&+F]F[-\\F][-\\^F][&F][&+F]"} "F" 3)
                 #(m/radians (+ (m/random -5 5) 35))
                 #(+ (m/random 2 4))))

(defn koch
  "Returns a mesh generated by an L-System that produces 3D version of a Koch curve."
  []
  (build-lsystem (expand-l-system {\F "FF-F-F&F-F-F+F"} "F" 3)
                 #(m/radians 90)
                 #(identity 3)))

(defn toroid
  "Generates a toroid using the L-System support functions."
  []
  (build-lsystem (take 48 (cycle [\F \+])) #(m/radians 15) #(identity 4)))
